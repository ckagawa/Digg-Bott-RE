#shitty way of doing this but too lazy to write an csv and parser
#the functions should all be in main along with parser, the dictionaries should be in a file
import discord
import youtube_dl
import random

#methods of the form (context, fixed inputs, user inputs) - not a great solution
#if I cared enough would have made seperate templates for ones that do or dont take input

class diggdict:
  #constructor
  def __init__(self,diggct):
    #this should have been in a csv but too lazy to write parser

    #in current form, it's a dictionary of form 'KEY' : ('FUNCTION','ARGS')
    #key will be chat command
    #function will be what chat command triggers
    #'args' is any fixed data associated with the chat command: saved images, auto-responses, etc
    self.diggct = dict({
      #commands with fixed output - these aren't mapped to correct values but you can do that yourself
        'digg':(self.digg,('1.png','2.png','3.png')),
        'sma':(self.write,'sma'),
        'stonks':(self.write,'stonks'),
        'blockchain':(self.write,'tam'),
      #commands with variable output : not necessary but avoids needing command lib
        'play':(self.play,None),
        'pause':(self.pause,None),
        'join':(self.join,None),
        'disconnect':(self.disconnect,None)
      })
    
#ctx - message context; package generated by chat command
#txt - text to be written/url of image to be drawn
#none - unused arg list to make all the methods have the same number of inputs
  async def write(ctx,txt,none):
    await ctx.send(txt)
#stupid
#ctx - message context; package generated by chat command
#imglist - list images to possibly be drawn
#none - unused arg list to make all the methods have the same number of inputs
  async def digg(ctx,imglist,none):
    await ctx.send(file=discord.File(random.choice(imglist)))
#MUSIC COMMANDS

#ctx - message context; package generated by chat command
#none - unused arg list to make all the methods have the same number of inputs
  async def join(ctx,none,none2):
    #author not in a voice channel
    if ctx.author.voice is None:
      await ctx.send("SMA")
    voice_channel = ctx.author.voice.channel
    #diggbot isnt in a voice channel
    if ctx.voice_client is None:
      await voice_channel.connect()
    #diggbot is in a voice channel
    else:
      await ctx.voice_client.move_to(voice_channel)
  
#ctx - message context; package generated by chat command
#none - unused arg list to make all the methods have the same number of inputs
  async def disconnect(ctx,none,none2):
    await ctx.voice_client.disconnect()

#ctx - message context; package generated by chat command
#none - unused arg list to make all the methods have the same number of inputs
#url - media url, presumably youtube video link
  async def play(ctx,none,url):
    #cuts whatever is currently playing
    ctx.voice_client.stop()
    #config settings for voice connections
    FFMPEG_OPTIONS = {'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5', 'options': '-vn'}
    #voice channel
    vc = ctx.voice_client
    #setup youtube config
    with youtube_dl.YoutubeDL({'format':'bestaudio'}) as ydl:
      #grab video information
      info = ydl.extract_info(url, download=False)
      #grab address of audio from the video information 
      url2 = info['formats'][0]['url']
      #attach audio to bot player
      source = await discord.FFmpegOpusAudio.from_probe(url2,**FFMPEG_OPTIONS)
      #start song
      vc.play(source)
  
#ctx - message context; package generated by chat command
#none - unused arg list to make all the methods have the same number of inputs
  async def pause(ctx,none,none2):
    #probably throws error if bot isn't currently playing or connected
    await ctx.voice_client.pause()
    await ctx.send("Paused")

#client - client of python script that needs to load this class
  async def setup(client):
    client.add_cog(diggdict())
